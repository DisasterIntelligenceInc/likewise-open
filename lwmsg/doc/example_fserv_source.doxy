/*
 * Copyright (c) Likewise Software.  All rights Reserved.
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the license, or (at
 * your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
 * General Public License for more details.  You should have received a copy
 * of the GNU Lesser General Public License along with this program.  If
 * not, see <http://www.gnu.org/licenses/>.
 *
 * LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
 * TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
 * WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
 * TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
 * LESSER GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
 * HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
 * TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
 * license@likewisesoftware.com
 */

/*
 * Module Name:
 *
 *        example_fserv_source.doxy
 *
 * Abstract:
 *
 *        Fserv source code walkthrough documentation page
 *
 * Authors: Brian Koropoff (bkoropoff@likewisesoftware.com)
 *
 */

/**
@page example_fserv_source Source Code Walkthrough

@section common Common

Creating a message protocol requires the following:

- A set of C data structures for exchanging information
- A corresponding set of type specifications which describe
  the layout and relationships of these structure
- A protocol specification which binds a set of message tags
  and payload types together into a description of the protocol

Because these elements are the same for both the client and server,
they should be factored out into their own library in order to
reduce memory usage at runtime.

The file <tt>include/protocol.h</tt> contains the basic C type
definitions and message type enumeration for the Fserv message
protocol.  The type and protocol specifications are contained
in <tt>src/protocol.c</tt>.

@subsection phs Message Structures

First, we define the types that will be used to transmit data
between client and server:

@dontinclude fserv/include/protocol.h
@skip Begin message structures
@until End message structures

Note the presence of the opaque <tt>FileHandle</tt> structure.
This type will be transmitted to the client as a handle.  The actual
definition of this structure is placed in <tt>protocol-server.h</tt>
which the client does not include.  This prevents client code from
erroneously attempting to dereference opaque handle types.

Also note that there are no <tt>OpenReply</tt> or <tt>CloseRequest</tt>
structures.  This is because both can be represented as <tt>FileHandle</tt>s
without being wrapped in an outer structure -- LWMsg permits any
pointer or pointer-like type to be the payload of a message.

@subsection mte Message Tag Enumeration

We then enumerates all possible message tags.  These tags
comprise the set of messages that may be sent between client and
server. Each element of the enumeration has a comment specifying
the C structure which is the payload for that type of message.

@skip Begin message enumeration
@until End message enumeration

For clarity, we organize messages into blocks of 3.  The first
message is the request sent to the server.  The second and third
are the success and error messages sent in response to the client.

LWMsg does not impose limitations on when certain message types
can be sent or by whom.  Although LWMsg guarantees that all
message payloads are well-formed, it is up to the application
to ensure that they are used appropriately and in the correct
sequence.  Future versions may support encoding some restrictions
directly into the protocol specification.

@subsection ts Type Specification

Each C structure that we want to use in the message protocol must
have a type specification describing it:

@dontinclude fserv/src/protocol.c
@skip Begin type specifications
@until End type specifications

@subsection ps Protocol Specification

Finally, we need a protocol specification which binds together
our enumerated set of messages tags and indicates the payload
type of each message.

@skip Begin protocol specification
@until End protocol specification

@section c Client

The client API implementation is contained in <tt>src/fserv.c</tt>.
It abstracts away the details of creating connections and exchanging
messages in order to perform Fserv operations.

@subsection connect Connecting

The client creates an #LWMsgPeer structure and connects it
to the local IPC server.  After this is done, any number of concurrent
calls can safely be dispatched to the server through this structure.
Therefore, a single global instance is lazily initialized in
<tt>fserv_construct()</tt> using the <tt>pthread_once()</tt> mechanism.

Before establishing the connection, we must first create a protocol
structure which describes the protocol the peer node will speak.
A protocol structure allows one or more protocol specifications
to be combined together.  First, the structure is created:

@dontinclude fserv/src/fserv.c
@skip Create protocol structure
@until ;

The protocol specification is then added:

@skip Add protocol spec
@until ;

We create the peer structure, passing in our protocol:

@skip Create peer
@until ;

Now we can add an endpoint to connect to:

@skip Add connect endpoint
@until ;

Finally, we connect the peer node to the server:

@skip Connect
@until ;

@subsection discon Disconnecting

To disconnect from the server, the client simply disconnects the peer
structure and then deletes it:

@skip Disconnect and delete
@until ;
@until ;

@subsection open Opening a File

Opening a file involves making a call to the server. First, we acquire a call handle
from the peer structure:

@skip Acquire call
@until ;

The input parameters to the call are initialized:

@skip Set up
@until ;
@until ;
@until ;
@until ;

The call can now be dispatched, sending the input parameters to the server and receiving back
the output parameters in a single operation:

@skip Make call
@until ;

If the call succeeds, <tt>out.tag</tt> is set to the type of the call result and
<tt>out.data</tt> is set to the result data.  The function then checks
what kind of result it received.  If it received a normal open response, it
returns the file handle to the caller.  The data is nulled out of the parameters
structure so that it is not freed later on.  If it received a failure response,
it extracts the error code and returns the error to the caller.

@skip switch
@until default:
@until }

Before the function returns, it needs to clean up all resources allocated during
the call.  Any output parameters from the call that we have not saved are destroyed,
and then the call handle is released.

@skip Clean up
@until ;
@until ;

@section s Server

**/